# transform
```java

  public static void processTransform(HippyArray transforms, double[] result) {
    double[] helperMatrix = sHelperMatrix.get();
    MatrixUtil.resetIdentityMatrix(result);

    for (int transformIdx = 0, size = transforms.size(); transformIdx < size; transformIdx++) {
      HippyMap transform = transforms.getMap(transformIdx);
      String transformType = transform.keySet().iterator().next();

      assert helperMatrix != null;
      MatrixUtil.resetIdentityMatrix(helperMatrix);
      Object value = transform.get(transformType);
      if ("matrix".equals(transformType) && value instanceof HippyArray) {
        HippyArray matrix = (HippyArray) value;
        for (int i = 0; i < 16; i++) {
          Object matrixValue = matrix.getObject(i);
          if (matrixValue instanceof Number) {
            helperMatrix[i] = ((Number) matrixValue).doubleValue();
          }
        }
      } else if ("perspective".equals(transformType) && value instanceof Number) {
        MatrixUtil.applyPerspective(helperMatrix, ((Number) value).doubleValue());
      } else if ("rotateX".equals(transformType)) {
        MatrixUtil.applyRotateX(helperMatrix, convertToRadians(transform, transformType));
      } else if ("rotateY".equals(transformType)) {
        MatrixUtil.applyRotateY(helperMatrix, convertToRadians(transform, transformType));
      } else if ("rotate".equals(transformType) || "rotateZ".equals(transformType)) {
        MatrixUtil.applyRotateZ(helperMatrix, convertToRadians(transform, transformType));
      } else if ("scale".equals(transformType) && value instanceof Number) {
        double scale = ((Number) value).doubleValue();
        MatrixUtil.applyScaleX(helperMatrix, scale);
        MatrixUtil.applyScaleY(helperMatrix, scale);
      } else if ("scaleX".equals(transformType) && value instanceof Number) {
        MatrixUtil.applyScaleX(helperMatrix, ((Number) value).doubleValue());
      } else if ("scaleY".equals(transformType)) {
        MatrixUtil.applyScaleY(helperMatrix, ((Number) value).doubleValue());
      } else if ("translate".equals(transformType) && value instanceof HippyArray) {
        double x = 0d, y = 0d, z = 0d;

        if (((HippyArray) value).size() > 0) {
          Object tranX = ((HippyArray) value).getObject(0);
          if (tranX instanceof Number) {
            x = ((Number) tranX).doubleValue();
          }
        }

        if (((HippyArray) value).size() > 1) {
          Object tranY = ((HippyArray) value).getObject(1);
          if (tranY instanceof Number) {
            y = ((Number) tranY).doubleValue();
          }
        }

        if (((HippyArray) value).size() > 2) {
          Object tranZ = ((HippyArray) value).getObject(2);
          if (tranZ instanceof Number) {
            z = ((Number) tranZ).doubleValue();
          }
        }
        MatrixUtil.applyTranslate3D(helperMatrix, x, y, z);
      } else if ("translateX".equals(transformType) && value instanceof Number) {
        MatrixUtil.applyTranslate2D(helperMatrix, ((Number) value).doubleValue(), 0d);
      } else if ("translateY".equals(transformType) && value instanceof Number) {
        MatrixUtil.applyTranslate2D(helperMatrix, 0d, ((Number) value).doubleValue());
      } else if ("skewX".equals(transformType)) {
        MatrixUtil.applySkewX(helperMatrix, convertToRadians(transform, transformType));
      } else if ("skewY".equals(transformType)) {
        MatrixUtil.applySkewY(helperMatrix, convertToRadians(transform, transformType));
      } else {
        RuntimeException runtimeException = new RuntimeException(
            "Unsupported transform type: " + transformType);
        runtimeException.printStackTrace();
      }

      MatrixUtil.multiplyInto(result, result, helperMatrix);
    }
  }

```

è¿™æ®µ Java æ–¹æ³•æ˜¯ä¸€ä¸ª çŸ©é˜µå˜æ¢å¤„ç†å™¨ï¼Œä¸»è¦ç”¨äºå°†ä¸€ä¸ªæ•°ç»„å½¢å¼çš„å¤šæ®µ CSS æ ·å¼ï¼ˆå¦‚ translate, rotate, scale ç­‰ï¼‰è§£æä¸ºä¸€ä¸ª æœ€ç»ˆ 4x4 å˜æ¢çŸ©é˜µï¼Œå¸¸è§äº React Nativeã€Hippy ç­‰æ¡†æ¶åœ¨åŸç”Ÿä¾§å¯¹ JS transform æ•°æ®çš„å¤„ç†ã€‚

â¸»

âœ… æ–¹æ³•ç­¾åè§£æï¼š

public static void processTransform(HippyArray transforms, double[] result)

	â€¢	transforms: JS ä¼ å…¥çš„ä¸€ç»„å˜æ¢æ“ä½œï¼ˆå¦‚ [{"translateX": 100}, {"scale": 1.5}]ï¼‰ï¼ŒåŒ…è£…ä¸º HippyArrayã€‚
	â€¢	result: æœ€ç»ˆç»“æœçŸ©é˜µï¼ˆé•¿åº¦ä¸º 16 çš„ double æ•°ç»„ï¼‰ï¼Œè¡¨ç¤ºå°†æ‰€æœ‰å˜æ¢åˆå¹¶åçš„ 4x4 å˜æ¢çŸ©é˜µã€‚

â¸»

ğŸ§± æ–¹æ³•æ•´ä½“é€»è¾‘ç»“æ„ï¼š
1.	åˆå§‹åŒ–è¾…åŠ©çŸ©é˜µ helperMatrix å’Œç›®æ ‡çŸ©é˜µ resultï¼ˆè®¾ç½®ä¸ºå•ä½çŸ©é˜µï¼‰ã€‚
2.	éå† transforms æ•°ç»„ï¼Œå¯¹æ¯ä¸€ä¸ª transformï¼ˆå¯¹è±¡ï¼‰ï¼š
â€¢	è¯»å–ç±»å‹å’Œå€¼ï¼ˆå¦‚ "translateX"ã€100ï¼‰
â€¢	åˆå§‹åŒ–è¾…åŠ©çŸ©é˜µä¸ºå•ä½çŸ©é˜µ
â€¢	æ ¹æ®ç±»å‹è°ƒç”¨ä¸åŒçš„ MatrixUtil.applyXXX() ç”Ÿæˆå¯¹åº”å˜æ¢çŸ©é˜µ
â€¢	å°†ç”Ÿæˆçš„å˜æ¢çŸ©é˜µä¸ result ç›¸ä¹˜ï¼ˆç»„åˆå˜æ¢ï¼‰

â¸»

ğŸ§  æ”¯æŒçš„å˜æ¢ç±»å‹åŠå¤„ç†æ–¹å¼ï¼š

å˜æ¢ç±»å‹	ç¤ºä¾‹	å¤„ç†æ–¹å¼ï¼ˆæ–¹æ³•ï¼‰
matrix	{matrix: [16ä¸ªæ•°]}	ç›´æ¥æ„é€ çŸ©é˜µ
perspective	{perspective: 500}	applyPerspective(...)
rotate, rotateX, rotateY, rotateZ	{rotateZ: '45deg'}	è½¬è§’åº¦ä¸ºå¼§åº¦åç”¨ applyRotateX/Y/Z
scale	{scale: 1.2}	X/Y è½´åŒæ—¶ç¼©æ”¾
scaleX, scaleY	å•ç‹¬è½´ç¼©æ”¾
translate	[x, y, z]	ä¸‰ç»´å¹³ç§»
translateX, translateY	äºŒç»´å¹³ç§»
skewX, skewY	æ–œåˆ‡ï¼ˆä½¿ç”¨å¼§åº¦ï¼‰
âŒ å…¶ä»–æœªæ”¯æŒ	æŠ›å¼‚å¸¸


â¸»

ğŸ” çŸ©é˜µä¹˜æ³•éƒ¨åˆ†

æ¯ä¸ªå˜æ¢æ“ä½œéƒ½ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„å˜æ¢çŸ©é˜µï¼Œæœ€åé€šè¿‡ï¼š

MatrixUtil.multiplyInto(result, result, helperMatrix);

å°†å…¶å åŠ åˆ°æœ€ç»ˆç»“æœçŸ©é˜µä¸­ï¼Œé¡ºåºç­‰ä»·äºï¼š

finalMatrix = Tn Ã— ... Ã— T2 Ã— T1 Ã— Identity

é¡ºåºç¬¦åˆ transform çš„å…ˆå†™åæ‰§è¡Œé€»è¾‘ã€‚

â¸»

âœ³ï¸ convertToRadians è¾…åŠ©å‡½æ•°

ä½ ä¼šçœ‹åˆ°å¤šä¸ªåœ°æ–¹è°ƒç”¨ï¼š

convertToRadians(transform, transformType)

è¿™ä¸ªå‡½æ•°åº”è¯¥æ˜¯å°† transform.get(transformType) çš„å€¼ä» "45deg" æˆ– "0.5rad" è¿™æ ·çš„å•ä½å­—ç¬¦ä¸²è½¬æ¢æˆ double ç±»å‹çš„å¼§åº¦å€¼ï¼Œä¾›æ—‹è½¬ã€å€¾æ–œç­‰æ“ä½œä½¿ç”¨ã€‚

â¸»

âœ… ç¤ºä¾‹è§£é‡Š

å¦‚æœä½ ä¼ å…¥çš„ transforms æ˜¯ï¼š

[
{ "translateX": 100 },
{ "rotateZ": "90deg" },
{ "scale": 2 }
]

å®ƒå°†æŒ‰é¡ºåºç”Ÿæˆï¼š
1.	translateX çŸ©é˜µ
2.	rotateZ çŸ©é˜µï¼ˆå°† â€œ90degâ€ è½¬æˆ Ï€/2 å¼§åº¦ï¼‰
3.	scale çŸ©é˜µï¼ˆç¼©æ”¾ X/Yï¼‰

æœ€åå®ƒä¼šæŠŠè¿™ä¸‰ä¸ªçŸ©é˜µä¾æ¬¡ä¹˜å…¥ç»“æœçŸ©é˜µä¸­ï¼Œå½¢æˆä¸€ä¸ªå®Œæ•´çš„ 4x4 å˜æ¢çŸ©é˜µã€‚

â¸»

ğŸ“Œ åº”ç”¨åœºæ™¯

è¿™ä¸ªæ–¹æ³•é€šå¸¸ç”¨åœ¨ï¼š
â€¢	åŸç”Ÿç«¯è¿˜åŸå‰ç«¯ transform æ•ˆæœ
â€¢	Web â†’ Native transform çš„æ¡¥æ¥ä¸­é—´å±‚
â€¢	OpenGL æˆ– Android Canvas ç»˜å›¾ä¸­è¿˜åŸ UI å˜æ¢
â€¢	ä¸‰ç»´æ¨¡å‹ã€è§†å›¾æŠ•å½±å¤„ç†

â¸»

å¦‚æœä½ è¿˜æƒ³çœ‹ MatrixUtil çš„å®ç°ã€æˆ–è€…æƒ³æŠŠè¿™ä¸ªæ–¹æ³•ç§»æ¤æˆ JS/TS å·¥å…·å‡½æ•°ï¼Œæˆ‘ä¹Ÿå¯ä»¥å¸®ä½ è½¬åŒ–ã€‚æœ‰éœ€è¦å—ï¼Ÿ